schema {
  query: GiaGraphQuery
  mutation: GiaGraphMutation
}

scalar String

scalar Boolean

scalar Float

scalar Int

scalar ID

"The `Date` scalar type represents a year, month and day in accordance with the [ISO-8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) standard."
scalar Date

"The `DateTime` scalar type represents a date and time. `DateTime` expects timestamps to be formatted in accordance with the [ISO-8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) standard."
scalar DateTime

"The `DateTimeOffset` scalar type represents a date, time and offset from UTC. `DateTimeOffset` expects timestamps to be formatted in accordance with the [ISO-8601](https:\/\/en.wikipedia.org\/wiki\/ISO_8601) standard."
scalar DateTimeOffset

"The `Seconds` scalar type represents a period of time represented as the total number of seconds."
scalar Seconds

"The `Milliseconds` scalar type represents a period of time represented as the total number of milliseconds."
scalar Milliseconds

scalar Decimal

"A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations."
type __Schema {
  "A list of all directives supported by this server."
  directives: [__Directive!]!
  "If this server supports mutation, the type that mutation operations will be rooted at."
  mutationType: __Type
  "The type that query operations will be rooted at."
  queryType: __Type!
  "If this server supports subscription, the type that subscription operations will be rooted at."
  subscriptionType: __Type
  "A list of all types supported by this server."
  types: [__Type!]!
}

"The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name and description, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types."
type __Type {
  description: String
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]
  fields(includeDeprecated: Boolean = false): [__Field!]
  inputFields: [__InputValue!]
  interfaces: [__Type!]
  kind: __TypeKind!
  name: String
  ofType: __Type
  possibleTypes: [__Type!]
}

"An enum describing what kind of type a given __Type is."
enum __TypeKind {
  "Indicates this type is a scalar."
  SCALAR
  "Indicates this type is an object.  `fields` and `possibleTypes` are valid fields."
  OBJECT
  "Indicates this type is an interface.  `fields` and `possibleTypes` are valid fields."
  INTERFACE
  "Indicates this type is a union.  `possibleTypes` is a valid field."
  UNION
  "Indicates this type is an num.  `enumValues` is a valid field."
  ENUM
  "Indicates this type is an input object.  `inputFields` is a valid field."
  INPUT_OBJECT
  "Indicates this type is a list.  `ofType` is a valid field."
  LIST
  "Indicates this type is a non-null.  `ofType` is a valid field."
  NON_NULL
}

"Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type."
type __Field {
  args: [__InputValue!]!
  deprecationReason: String
  description: String
  isDeprecated: Boolean!
  name: String!
  type: __Type!
}

"Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value."
type __InputValue {
  "A GraphQL-formatted string representing the default value for this input value."
  defaultValue: String
  description: String
  name: String!
  type: __Type!
}

"One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string."
type __EnumValue {
  deprecationReason: String
  description: String
  isDeprecated: String!
  name: String!
}

"A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor."
type __Directive {
  args: [__InputValue!]!
  description: String
  locations: [__DirectiveLocation!]!
  name: String!
  onField: Boolean!
  onFragment: Boolean!
  onOperation: Boolean!
}

"A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies."
enum __DirectiveLocation {
  "Location adjacent to a query operation."
  QUERY
  "Location adjacent to a mutation operation."
  MUTATION
  "Location adjacent to a subscription operation."
  SUBSCRIPTION
  "Location adjacent to a field."
  FIELD
  "Location adjacent to a fragment definition."
  FRAGMENT_DEFINITION
  "Location adjacent to a fragment spread."
  FRAGMENT_SPREAD
  "Location adjacent to an inline fragment."
  INLINE_FRAGMENT
  "Location adjacent to a schema definition."
  SCHEMA
  "Location adjacent to a scalar definition."
  SCALAR
  "Location adjacent to an object type definition."
  OBJECT
  "Location adjacent to a field definition."
  FIELD_DEFINITION
  "Location adjacent to an argument definition."
  ARGUMENT_DEFINITION
  "Location adjacent to an interface definition."
  INTERFACE
  "Location adjacent to a union definition."
  UNION
  "Location adjacent to an enum definition"
  ENUM
  "Location adjacent to an enum value definition"
  ENUM_VALUE
  "Location adjacent to an input object type definition."
  INPUT_OBJECT
  "Location adjacent to an input object field definition."
  INPUT_FIELD_DEFINITION
}

type GiaGraphQuery {
  administration: AdministrationType
  customer(shortcut: ID): [CustomerType]
  process: ProcessType
  user: UserType
}

type CustomerType {
  addressLine1: String
  city: String
  defaultRoles: [Int]
  domainSuffixes: [String]
  giaDebitNumber: String
  giaShortcut: String
  name: String
  properties: [CustomerPropertyType]
  service: ServiceGraphType
  serviceManagement: ServiceManagementType
  zip: String
}

type CustomerPropertyType {
  name: String
  value: String
}

type ServiceGraphType {
  citrix: CitrixGraphType
  client: ClientGraphType
  file: FileType
  hypervisor: HypervisorType
  identity: IdentityType
  infrastructure: InfrastructureType
  messaging(config: MessagingConfigurationInputType): MessagingType
  network: NetworkGraphType
  platform: PlatformType
  print: PrintType
  sap: SapType
  securityPatching: SecurityPatchingType
  systemManagement: SystemManagementType
  vasco: VascoType
}

type PlatformType {
  servers(where: UidFilterType): [CustomServerType]
}

type CustomServerType {
  active: ActiveState
  alive: Boolean
  antimalware: Antimalware
  assetNumbers: [String]
  assignedServices: [String]
  availability(month: Date): AvailabilityType
  backupPolicy: String
  businessModules: [String]
  comment: String
  consoleUsages: [ConsoleUsageType]
  contact: String
  contractNumbers: [String]
  cpus: [CPU]
  createdAt: DateTime
  customer: String
  description: String
  disks: [Disk]
  distinguishedName: String
  domain: String
  getAssignedIpAddresses: [IpAddress]
  getAssignedServices: [Service]
  getBusinessModules: [BusinessModule]
  getContact: User
  getCustomer: Customer
  getHostVirtualMachines: [Vm]
  getSecondaryContact: User
  history: [HistoryItem]
  hostDetails: HostDetails
  id: ID
  imacs: [ServerImacsType]
  infrastructure: String
  investmentNumbers: [String]
  ipAddresses: [String]
  isHost: Boolean
  isManagedByGIA: Boolean
  isNotBillable: Boolean
  isServer: Boolean
  isVirtualMachine: Boolean
  isVisibleToCustomer: Boolean
  lastLogon: DateTime
  lastOfflineTime: DateTime
  lastOnlineTime: DateTime
  manufacturer: String
  model: String
  netbiosName: String
  numberOfCores: Float
  numberOfLogicalProcessors: Float
  numberOfPhysicalProcessors: Float
  onlineStatus: Boolean
  operatingSystem: Os
  patchState: PatchStateType
  patchWindow: String
  performance: PlatformPerformanceType
  principalName: String
  rebootState: Int
  region: String
  roles: [String]
  sccmAgent: Int
  sccmResourceId: String
  scomAgent: Int
  secondaryContact: String
  serialNumber: String
  serviceWindowApp: String
  serviceWindowPft: String
  sources: [String!]!
  systemClass: SystemClass
  systemClassTarget: SystemClass
  systemType: String
  totalDiskGB: Float
  totalMemoryMB: Float
  uid: String!
  updatedAt: DateTime
  version: ServerVersion
  volumes: [Volume]
}

enum ActiveState {
  INACTIVE
  ACTIVE
}

type HistoryItem {
  id: Int!
  mutatedBy: String
  mutationContext: String
  patch: [ChangeTrackingProperty]
  timeStamp: Date!
  uid: String!
}

type ChangeTrackingProperty {
  fromTypeName: String
  fromValue: String
  parentPropertyName: String
  propertyName: String
  toTypeName: String
  toValue: String
}

enum SystemClass {
  NA
  BE
  HA
  DT
  DT_PREM
}

type CPU {
  deviceId: String
  family: Int
  is64Bit: Boolean
  manufacturer: String
  maxClockSpeed: Int
  name: String
  normSpeed: Int
  numberOfCores: Int
  numberOfLogicalProcessors: Int
  socketDesignation: String
  status: String
}

type Disk {
  caption: String
  description: String
  deviceId: String
  index: Int
  interfaceType: String
  manufacturer: String
  mediaType: String
  model: String
  name: String
  partitions: [Partition]
  pnpDeviceId: String
  sizeMB: Float
}

type Partition {
  bootable: Boolean
  bootPartition: Boolean
  description: String
  deviceId: String
  name: String
  primaryPartition: Int
  sizeMB: Float
  systemName: String
  type: String
}

type Volume {
  description: String
  deviceId: String
  driveType: Int
  fileSystem: String
  freeSpaceGB: Float
  name: String
  sizeMB: Float
  volumeName: String
}

type Os {
  bootDevice: String
  buildNumber: String
  caption: String
  countryCode: Int
  description: String
  installDate: DateTime
  lastBootUpTime: DateTime
  locale: String
  manufacturer: String
  name: String
  organization: String
  productType: Int
  registeredUser: String
  systemDirectory: String
  totalVirtualMemorySizeMB: Float
  totalVisibleMemorySizeMB: Float
  version: String
  windowsDirectory: String
}

type Antimalware {
  antispywareEnabled: Boolean
  antispywareUpdate: DateTime
  antivirusEnabled: Boolean
  antivirusUpdate: DateTime
  enabled: Boolean
  onAccessProtectionEnabled: Boolean
  rtpEnabled: Boolean
  version: String
}

type HostDetails {
  clusterName: String
  dataCenterName: String
  notes: String
}

type ConsoleUsageType {
  consoleMinutes: Int
  getUser: User
  lastLogon: DateTime
  numberOfLogins: Int
  uniqueUserName: String
  userPrincipalName: String
}

type User {
  active: ActiveState
  createdAt: DateTime
  customer: String
  description: String
  displayName: String
  firstName: String
  gender: String
  history: [HistoryItem]
  id: ID
  lastName: String
  location: String
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
  userName: String
  userPrincipalName: String
  version: UserVersion
}

type UserVersion {
  active: ActiveState
  firstName: String
  lastName: String
  location: String
  mutatedBy: String
  mutationContext: String
  number: String
  state: CIState
  ticketNumber: String
  version: Int
}

enum CIState {
  NONE
  IN_DEVELOPMENT
  IN_USE
  IN_REMOVAL
  REMOVED
}

type Vm {
  active: ActiveState
  clusterName: String
  collector: String
  cpu: Float
  createdAt: DateTime
  dataCenterName: String
  disk: Float
  displayName: String
  fullName: String
  getGuestOs: System
  getHost: System
  guestOs: String
  history: [HistoryItem]
  host: String
  id: ID
  ipAddresses: [String]
  memory: Float
  monitoringGroup: String
  sources: [String!]!
  storage: [String]
  storageFull: [String]
  uid: String!
  updatedAt: DateTime
  vCenterName: String
  vmType: String
  vmVersion: String
}

type System {
  active: ActiveState
  alive: Boolean
  antimalware: Antimalware
  assetNumbers: [String]
  assignedServices: [String]
  backupPolicy: String
  businessModules: [String]
  comment: String
  consoleUsages: [ConsoleUsageType]
  contact: String
  contractNumbers: [String]
  cpus: [CPU]
  createdAt: DateTime
  customer: String
  description: String
  disks: [Disk]
  distinguishedName: String
  domain: String
  getAssignedIpAddresses: [IpAddress]
  getAssignedServices: [Service]
  getBusinessModules: [BusinessModule]
  getContact: User
  getCustomer: Customer
  getHostVirtualMachines: [Vm]
  getSecondaryContact: User
  history: [HistoryItem]
  hostDetails: HostDetails
  id: ID
  infrastructure: String
  investmentNumbers: [String]
  ipAddresses: [String]
  isHost: Boolean
  isManagedByGIA: Boolean
  isNotBillable: Boolean
  isServer: Boolean
  isVirtualMachine: Boolean
  isVisibleToCustomer: Boolean
  lastLogon: DateTime
  lastOfflineTime: DateTime
  lastOnlineTime: DateTime
  manufacturer: String
  model: String
  netbiosName: String
  numberOfCores: Float
  numberOfLogicalProcessors: Float
  numberOfPhysicalProcessors: Float
  onlineStatus: Boolean
  operatingSystem: Os
  patchWindow: String
  principalName: String
  rebootState: Int
  region: String
  roles: [String]
  sccmAgent: Int
  sccmResourceId: String
  scomAgent: Int
  secondaryContact: String
  serialNumber: String
  serviceWindowApp: String
  serviceWindowPft: String
  sources: [String!]!
  systemClass: SystemClass
  systemType: String
  totalDiskGB: Float
  totalMemoryMB: Float
  uid: String!
  updatedAt: DateTime
  volumes: [Volume]
}

type BusinessModule {
  active: ActiveState
  createdAt: DateTime
  customer: String!
  getCustomer: Customer
  history: [HistoryItem]
  id: ID
  name: String!
  number: String!
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
}

type Customer {
  active: ActiveState
  city: String
  comment: String
  createdAt: DateTime
  debitNumber: String
  description: String
  domains: [String]
  history: [HistoryItem]
  id: ID
  itsmOrgId: String
  name: String
  shortcut: String
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
  zip: String
}

type Service {
  active: ActiveState
  createdAt: DateTime
  description: String
  displayName: String
  history: [HistoryItem]
  id: ID
  name: String
  serviceId: String
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
}

type IpAddress {
  active: ActiveState
  alive: Boolean
  createdAt: DateTime
  customer: String
  gestioId: String
  getNetwork: Network
  history: [HistoryItem]
  hostDescription: String
  hostname: String
  id: ID
  ip: String
  ipNumeric: String
  ipVersion: String
  lastResponse: Date
  loc: String
  netbiosName: String
  redNum: String
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
}

type Network {
  active: ActiveState
  createdAt: DateTime
  customer: String
  description: String
  history: [HistoryItem]
  id: ID
  ipVersion: String
  loc: String
  net: String
  notes: String
  redNum: String
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
}

type ServerVersion {
  active: ActiveState
  businessModules: [String]
  category: SystemClass
  contact: String
  description: String
  location: String
  mutatedBy: String
  mutationContext: String
  number: String
  organisation: String
  state: CIState
  ticketNumber: String
  type: String
  version: Int
}

union ServerImacsType = ServerSetupImac | ServerDecomImac | ServerChangeImac

type ServerSetupImac {
  archId: String
  backupPolicy: String
  backupUser: String
  businessModules: [String]
  computeCluster: String
  currentState: String
  customer: String
  defaultGateway: String
  description: String
  domain: String
  explanation: String
  getBackupUser: User
  getPrimaryOwner: User
  getRequestedBy: User
  getSccmUser: User
  getScepUser: User
  getScomUser: User
  getScsmUser: User
  getSecondaryOwner: User
  getVisionAppUser: User
  hostname: String
  imacGuid: GuidGraphType
  imacId: String
  ip: String
  mutatedBy: String
  mutationContext: String!
  networkComment: String
  networkVlan: String
  note: String
  passwordSaved: Boolean
  patchWindow: String
  platformConfigComment: String
  platformDistributionComment: String
  platformInstallComment: String
  primaryDns: String
  primaryOwner: String
  region: String
  requestedAt: DateTime
  requestedBy: String
  satComment: String
  sccmUser: String
  scepUser: String
  scomUser: String
  scsmUser: String
  secondaryDns: String
  secondaryOwner: String
  serverSize: ServerSize
  serverType: String
  sla: ServerSLA
  storageSystem: String
  subnetMask: String
  systemClass: SystemClass
  ticketNumber: String!
  visionAppUser: String
  vlan: String
  vlanId: String
}

"Globally Unique Identifier."
scalar GuidGraphType

type ServerSize {
  cpu: Int
  disk: Int
  memory: Int
  name: String
}

type ServerSLA {
  application: String
  platform: String
}

type ServerDecomImac {
  imacGuid: GuidGraphType
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type ServerChangeImac {
  active: ActiveState
  assetNumbers: [String]
  assignedServices: [String]
  backupPolicy: String
  businessModules: [String]
  cIState: CIState
  comment: String
  contractNumbers: [String]
  customer: String
  description: String
  imacGuid: GuidGraphType
  infrastructure: String
  investmentNumbers: [String]
  isManagedByGIA: Boolean
  isVisibleToCustomer: Boolean
  mutatedBy: String
  mutationContext: String!
  note: String
  patchWindow: String
  primaryOwner: String
  region: String
  requestedAt: DateTime
  secondaryOwner: String
  serviceWindowApp: String
  serviceWindowPft: String
  systemClass: SystemClass
  ticketNumber: String!
}

type PlatformPerformanceType {
  cpu: CPUType
  disk: DiskType
  memory: MemoryType
}

type CPUType {
  processorTime(startTime: Date endTime: Date sourceType: PlatformPerfDataSourceType): [LinearNumberDataSetType]
}

type LinearNumberDataSetType {
  name: String
  unit: String
  values: [LinearNumberValueType]
}

type LinearNumberValueType {
  date: DateTime
  value: Float
}

enum PlatformPerfDataSourceType {
  RAW
  HOURLY
  DAILY
}

type DiskType {
  reads(startTime: Date endTime: Date sourceType: PlatformPerfDataSourceType): [LinearNumberDataSetType]
  usage(startTime: Date endTime: Date sourceType: PlatformPerfDataSourceType): [LinearNumberDataSetType]
  writes(startTime: Date endTime: Date sourceType: PlatformPerfDataSourceType): [LinearNumberDataSetType]
}

type MemoryType {
  available(startTime: Date endTime: Date sourceType: PlatformPerfDataSourceType): [LinearNumberDataSetType]
  used(startTime: Date endTime: Date sourceType: PlatformPerfDataSourceType): [LinearNumberDataSetType]
}

type AvailabilityType {
  counter: [LinearNumberDataSetType]
  deadLine: Float
  status: AvailabilityStatus
}

enum AvailabilityStatus {
  UP
  DOWN
  UNKNOWN
}

type PatchStateType {
  computerName: String
  evalState: String
  issues: [Issue]
  lastBoot: String
  lastStateReceived: Date
  loggedInuser: [String]
  minutesSinceLastBoot: Float
  missingUpdates: Boolean
  oS: String
  rebootRequired: Boolean
  runningUpdates: Boolean
  secondsSinceLastInfo: Float
  serviceWindowNow: Boolean
  state: State
  updates: [String]
  userLoggedOn: Boolean
}

enum State {
  SUCCESS
  WARNING
  DANGER
}

enum Issue {
  MISSING_UPDATES
  LONG_TIME_SINCE_LAST_INFO
  LONG_TIME_SINCE_LAST_BOOT
}

input UidFilterType {
  uid: String
}

type SecurityPatchingType {
  servers(where: UidFilterType): [CustomServerType]
}

type NetworkGraphType {
  module(name: ID): [ModuleType]
  services(name: String config: [NetworkServiceInputType]): [NetworkServicesType]
}

type ModuleType {
  availability: AvailabilityType
  counter: String
  device: String
  location: String
  name: String
  threshold: Float
}

type NetworkServicesType {
  availabilityCounter(device: String serviceName: String): [NetworkAvailabilityCounterType]
  id: String!
  performanceCounter(hostName: String counter: String interfaceName: String): [NetworkPerformanceCounterType]
  serviceTitle: String
}

type NetworkPerformanceCounterType {
  counter: String
  hostName: String
  interfaceName: String
  location: String
  performance(startTime: Date endTime: Date sourceType: NetworkPerfDataSourceType): [LinearNumberDataSetType]
}

enum NetworkPerfDataSourceType {
  DAY
  WEEK
  MONTH
  YEAR
}

type NetworkAvailabilityCounterType {
  availability(month: Date): AvailabilityType
  deadLine: Float
  hostName: String
  location: String
  serviceName: String!
}

input NetworkServiceInputType {
  serviceTitle: String!
  performanceCounter: [NetworkPerformanceCounterInputType]
  availabilityCounter: [NetworkAvailabilityCounterInputType]
}

input NetworkPerformanceCounterInputType {
  location: String!
  hostName: String!
  interfaceName: String
  counter: String
}

input NetworkAvailabilityCounterInputType {
  location: String!
  hostName: String!
  serviceName: String
  deadLine: Float
}

type CitrixGraphType {
  licencing: CitrixLicencingType
  store(name: ID): [StoreType]
}

type StoreType {
  description: String
  errorMessage: String
  name: String
  state: Int
}

type CitrixLicencingType {
  usage: CitrixLicencingUsageType
}

type CitrixLicencingUsageType {
  history(year: DateTime): [CitrixLicencingUsageHistoryCounterType]
  users(month: DateTime): [CitrixLicencingUserType]
}

type CitrixLicencingUserType {
  domain: String
  id: ID
  isFree: Boolean
  userName: String
}

type CitrixLicencingUsageHistoryCounterType {
  name: String
  values: [CitrixLicencingUsageHistoryDataType]
}

type CitrixLicencingUsageHistoryDataType {
  count: Float
  date: DateTime
}

type ClientGraphType {
  applications(productName: ID): [ApplicationType]
  assignableApps: [AssignableAppsType]
  devices(name: ID): [DeviceType]
  resource: ResourceType
}

type DeviceType {
  assignedApps: [AssignedAppType]
  id: ID
  identifyingNumber: String
  inventory: [InventoryType]
  isActive: Boolean
  isAssigned: Boolean
  isClient: Boolean
  isObsolete: Boolean
  isVirtualMachine: Boolean
  malwareAtRisk: Boolean
  malwareDepState: Int
  malwareError: String
  malwareProtected: Boolean
  malwareSignatureOlderThan7Days: Boolean
  malwareSignatureUpTo1DayOld: Boolean
  malwareSignatureUpTo3DaysOld: Boolean
  malwareSignatureUpTo7DaysOld: Boolean
  malwareUnhealthy: Boolean
  malwareUnsupported: Boolean
  modelName: String
  name: String
  primaryUser: String
  resourceID: Int
  users: [UsersType]
  vendor: String
  version: String
}

type AssignedAppType {
  collID: String
  collName: String
}

type UsersType {
  isActive: Boolean
  resourceID: Int
  sources: [String]
  types: [String]
  uniqueUserName: String
}

type InventoryType {
  categoryName: String
  familyName: String
  machineName: String
  os: String
  productName: String
  publisher: String
  version: String
}

type ApplicationType {
  clients: [String]
  id: String
  productName: String
  publisher: String
  total: Int
  version: String
}

type AssignableAppsType {
  id: String!
  name: String!
}

type ResourceType {
  clients(where: UidFilterType): [ClientType]
  dockingstations(where: UidFilterType): [Dockingstation]
  monitors(where: UidFilterType): [Monitor]
  printers(where: UidFilterType): [Printer]
  users(where: UidFilterType): [User]
}

type ClientType {
  active: ActiveState
  alive: Boolean
  antimalware: Antimalware
  assetNumbers: [String]
  assignedServices: [String]
  backupPolicy: String
  businessModules: [String]
  comment: String
  consoleUsages: [ConsoleUsageType]
  contact: String
  contractNumbers: [String]
  cpus: [CPU]
  createdAt: DateTime
  customer: String
  description: String
  disks: [Disk]
  distinguishedName: String
  domain: String
  getAssignedIpAddresses: [IpAddress]
  getAssignedServices: [Service]
  getBusinessModules: [BusinessModule]
  getContact: User
  getCustomer: Customer
  getHostVirtualMachines: [Vm]
  getSecondaryContact: User
  history: [HistoryItem]
  hostDetails: HostDetails
  id: ID
  imacs: [ClientImacsType]
  infrastructure: String
  investmentNumbers: [String]
  ipAddresses: [String]
  isHost: Boolean
  isManagedByGIA: Boolean
  isNotBillable: Boolean
  isServer: Boolean
  isVirtualMachine: Boolean
  isVisibleToCustomer: Boolean
  lastLogon: DateTime
  lastOfflineTime: DateTime
  lastOnlineTime: DateTime
  location: String
  manufacturer: String
  model: String
  netbiosName: String
  numberOfCores: Float
  numberOfLogicalProcessors: Float
  numberOfPhysicalProcessors: Float
  onlineStatus: Boolean
  operatingSystem: Os
  patchWindow: String
  principalName: String
  rebootState: Int
  region: String
  roles: [String]
  sccmAgent: Int
  sccmResourceId: String
  scomAgent: Int
  secondaryContact: String
  serialNumber: String
  serviceWindowApp: String
  serviceWindowPft: String
  sources: [String!]!
  systemClass: SystemClass
  systemType: String
  totalDiskGB: Float
  totalMemoryMB: Float
  uid: String!
  updatedAt: DateTime
  version: ClientVersion
  volumes: [Volume]
}

type ClientVersion {
  active: ActiveState
  businessModules: [String]
  category: ClientClass
  contact: String
  description: String
  location: String
  mutatedBy: String
  mutationContext: String
  number: String
  organisation: String
  state: CIState
  ticketNumber: String
  type: String
  version: Int
}

enum ClientClass {
  NOTEBOOK
  DESKTOP
}

union ClientImacsType = ClientSetupImac | ClientDecomImac | ClientChangeImac

type ClientSetupImac {
  assignTo: String!
  businessModules: [String]
  clientType: ClientClass
  currentState: String!
  customer: String!
  hostname: String!
  imacGuid: GuidGraphType
  location: String!
  model: String!
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  serialNumber: String!
  ticketNumber: String!
}

type ClientDecomImac {
  imacGuid: GuidGraphType
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type ClientChangeImac {
  assignTo: String!
  businessModules: [String]
  customer: String!
  imacGuid: GuidGraphType
  location: String!
  model: String!
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type Printer {
  active: ActiveState
  businessModules: [String]
  comment: String
  contact: String
  createdAt: DateTime
  customer: String
  description: String
  getBusinessModules: [BusinessModule]
  getContact: User
  getCustomer: Customer
  history: [HistoryItem]
  id: ID
  imacs: [PrinterImacsType]
  location: String
  model: String
  netbiosName: String
  serialNumber: String
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
  version: Printer
}

union PrinterImacsType = PrinterSetupImac | PrinterDecomImac | PrinterChangeImac

type PrinterSetupImac {
  assignTo: String
  businessModules: [String]
  comment: String
  customer: String
  description: String
  hostname: String
  imacGuid: GuidGraphType
  location: String
  model: String
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  serialNumber: String
  ticketNumber: String!
}

type PrinterDecomImac {
  imacGuid: GuidGraphType
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type PrinterChangeImac {
  assignTo: String
  businessModules: [String]
  comment: String
  customer: String
  description: String
  imacGuid: GuidGraphType
  location: String
  model: String
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type Monitor {
  active: ActiveState
  businessModules: [String]
  comment: String
  contact: String
  createdAt: DateTime
  customer: String
  description: String
  getBusinessModules: [BusinessModule]
  getContact: User
  getCustomer: Customer
  history: [HistoryItem]
  id: ID
  imacs: [MonitorImacsType]
  location: String
  model: String
  serialNumber: String
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
  version: Monitor
}

union MonitorImacsType = MonitorSetupImac | MonitorDecomImac | MonitorChangeImac

type MonitorSetupImac {
  assignTo: String
  businessModules: [String]
  comment: String
  customer: String
  description: String
  imacGuid: GuidGraphType
  location: String
  model: String
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  serialNumber: String
  ticketNumber: String!
}

type MonitorDecomImac {
  imacGuid: GuidGraphType
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type MonitorChangeImac {
  assignTo: String
  businessModules: [String]
  comment: String
  customer: String
  description: String
  imacGuid: GuidGraphType
  location: String
  model: String
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type Dockingstation {
  active: ActiveState
  businessModules: [String]
  comment: String
  contact: String
  createdAt: DateTime
  customer: String
  description: String
  getBusinessModules: [BusinessModule]
  getContact: User
  getCustomer: Customer
  history: [HistoryItem]
  id: ID
  imacs: [DockingstationImacsType]
  location: String
  model: String
  serialNumber: String
  sources: [String!]!
  uid: String!
  updatedAt: DateTime
  version: Dockingstation
}

union DockingstationImacsType = DockingstationSetupImac | DockingstationDecomImac | DockingstationChangeImac

type DockingstationSetupImac {
  assignTo: String
  businessModules: [String]
  comment: String
  customer: String
  description: String
  imacGuid: GuidGraphType
  location: String
  model: String
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  serialNumber: String
  ticketNumber: String!
}

type DockingstationDecomImac {
  imacGuid: GuidGraphType
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type DockingstationChangeImac {
  assignTo: String
  businessModules: [String]
  comment: String
  customer: String
  description: String
  imacGuid: GuidGraphType
  location: String
  model: String
  mutatedBy: String
  mutationContext: String!
  note: String
  requestedAt: DateTime
  ticketNumber: String!
}

type InfrastructureType {
  allServers(where: UidFilterType): [CustomServerType]
  servers(where: UidFilterType): [CustomServerType]
}

type FileType {
  servers(where: UidFilterType): [CustomServerType]
}

type PrintType {
  servers(where: UidFilterType): [CustomServerType]
}

type HypervisorType {
  servers(where: UidFilterType): [CustomHostType]
}

type CustomHostType {
  active: ActiveState
  alive: Boolean
  antimalware: Antimalware
  assetNumbers: [String]
  assignedServices: [String]
  availability(month: Date): AvailabilityType
  backupPolicy: String
  businessModules: [String]
  comment: String
  consoleUsages: [ConsoleUsageType]
  contact: String
  contractNumbers: [String]
  cpus: [CPU]
  createdAt: DateTime
  customer: String
  description: String
  disks: [Disk]
  distinguishedName: String
  domain: String
  getAssignedIpAddresses: [IpAddress]
  getAssignedServices: [Service]
  getBusinessModules: [BusinessModule]
  getContact: User
  getCustomer: Customer
  getHostVirtualMachines: [Vm]
  getSecondaryContact: User
  getVirtualMachines: [Vm]
  history: [HistoryItem]
  hostDetails: HostDetails
  id: ID
  imacs: [ServerImacsType]
  infrastructure: String
  investmentNumbers: [String]
  ipAddresses: [String]
  isHost: Boolean
  isManagedByGIA: Boolean
  isNotBillable: Boolean
  isServer: Boolean
  isVirtualMachine: Boolean
  isVisibleToCustomer: Boolean
  lastLogon: DateTime
  lastOfflineTime: DateTime
  lastOnlineTime: DateTime
  manufacturer: String
  model: String
  netbiosName: String
  numberOfCores: Float
  numberOfLogicalProcessors: Float
  numberOfPhysicalProcessors: Float
  onlineStatus: Boolean
  operatingSystem: Os
  patchState: PatchStateType
  patchWindow: String
  performance: PlatformPerformanceType
  principalName: String
  rebootState: Int
  region: String
  roles: [String]
  sccmAgent: Int
  sccmResourceId: String
  scomAgent: Int
  secondaryContact: String
  serialNumber: String
  serviceWindowApp: String
  serviceWindowPft: String
  sources: [String!]!
  systemClass: SystemClass
  systemClassTarget: SystemClass
  systemType: String
  totalDiskGB: Float
  totalMemoryMB: Float
  uid: String!
  updatedAt: DateTime
  version: ServerVersion
  volumes: [Volume]
}

type SapType {
  servers(where: UidFilterType): [CustomServerType]
}

type SystemManagementType {
  servers(where: UidFilterType): [CustomServerType]
}

type MessagingType {
  availability(ids: [ID] month: Date): [MessagingAvailabilityType]
  config: MessagingConfigurationType
  mailboxes: [Mailbox]
  responsePerformanceMailbox(from: DateTime to: DateTime): [MessagingPerformanceMailboxType]
  responsePerformancePercent(ids: [ID]): [MessagingPerformancePercentType]
  responsePerformancePercentile(ids: [ID]): [MessagingPerformancePercentilType]
}

type MessagingConfigurationType {
  availability: [MessagingAvailabilityConfigType]
  enableMailboxChart: Boolean
  organisation: String
  performancePercent: [MessagingPerformancePercentConfigType]
  performancePercentile: [MessagingPerformancePercentilConfigType]
}

type MessagingPerformancePercentilConfigType {
  percentile: Int
  threshold: Float
}

type MessagingPerformancePercentConfigType {
  thresholdInSec: Float
  thresholdSLA: Float
}

type MessagingAvailabilityConfigType {
  thresholdInSec: Float
  thresholdSLA: Float
}

type Mailbox {
  customAttribute15: String!
  dbName: String!
  deletedItemCount: Int!
  displayName: String!
  isMailboxEnabled: Boolean!
  isResource: Boolean!
  itemCount: Int!
  organization: String!
  recipientType: String!
  totalDeletedItemSizeMB: Decimal
  totalItemSizeMB: Decimal
  userPrincipalName: String!
}

type MessagingPerformancePercentilType {
  id: ID
  percentile: Int
  threshold: Float
  values(from: DateTime to: DateTime): [MessagingPerformancePercentileDataType]
}

type MessagingPerformancePercentileDataType {
  percentileLatency: Int!
  time: DateTime
}

type MessagingPerformanceMailboxType {
  name: String!
  values: [MessagingPerformanceMailboxDataType]
}

type MessagingPerformanceMailboxDataType {
  latency: Int!
  time: DateTime
}

type MessagingPerformancePercentType {
  id: ID
  thresholdInSec: Float
  thresholdSLA: Float
  values(from: DateTime to: DateTime): [MessagingPerformancePercentDataType]
}

type MessagingPerformancePercentDataType {
  overThresholdCount: Float!
  overThresholdPercentage: Float!
  time: DateTime
  underThresholdCount: Float!
  underThresholdPercentage: Float!
}

type MessagingAvailabilityType {
  counter: [LinearNumberDataSetType]
  deadLine: Float
  id: ID
  status: AvailabilityStatus
  thresholdInSec: Float
  thresholdSLA: Float
}

input MessagingConfigurationInputType {
  organisation: String
  enableMailboxChart: Boolean
  performancePercentile: [MessagingPerformancePercentilInputType]
  performancePercent: [MessagingPerformancePercentInputType]
  availability: [MessagingAvailabilityInputType]
}

input MessagingPerformancePercentilInputType {
  percentile: Int
  threshold: Float
}

input MessagingPerformancePercentInputType {
  thresholdInSec: Float
  thresholdSLA: Float
}

input MessagingAvailabilityInputType {
  thresholdInSec: Float
  thresholdSLA: Float
}

type VascoType {
  availability(month: Date): VascoAvailabilityType
  management: VascoManagementType
  maxTokensPerUser: Int
  tokensAvailable: Boolean
  userAvailability(month: Date userName: String): [VascoAvailabilityType]
}

type VascoAvailabilityType {
  counter: [LinearNumberDataSetType]
  deadLine: Float
  id: ID
  status: AvailabilityStatus
}

type VascoManagementType {
  appliance(applianceName: String): [VascoApplianceType]
  monitoringUser: [VascoMonitoringUserType]
}

type VascoApplianceType {
  availability(month: Date): VascoAvailabilityType
  checkCounter: Int!
  healthState: VascoMonitoringState
  log: [ApplianceLogType]
  name: String!
}

enum VascoMonitoringState {
  HEALTHY
  WARNING
  ERROR
}

type ApplianceLogType {
  appliance: String!
  eventDetails: String!
  eventState: VascoMonitoringState
  eventTime: DateTime
}

type VascoMonitoringUserType {
  checkCounter: Int!
  customerShortcut: String!
  healthState: VascoMonitoringState
  log: [UserLogType]
  name: String!
}

type UserLogType {
  eventDetails: String!
  eventState: VascoMonitoringState
  eventTime: DateTime
  user: String!
}

type IdentityType {
  availability(month: Date): VascoAvailabilityType
  servers(where: UidFilterType): [CustomServerType]
}

type ServiceManagementType {
  servers(where: UidFilterType): [CustomServerType]
}

type UserType {
  activites(shortcut: ID!): [ActivityType]
  customer: String
  displayName: String
  mobile: String
  userPrincipalName: String
  vascoTokens: [VascoTokenType]
}

type ActivityType {
  description: String
  name: String
}

type VascoTokenType {
  activationCode: String
  assignedDate: DateTime
  serialNumber: ID
  type: VascoTokenKind
}

enum VascoTokenKind {
  UNKNOWN
  MOBILE
  WINDOWS
  DIGI_PASS
  VIRTUAL
}

type AdministrationType {
  security: SecurityGraphType
}

type SecurityGraphType {
  activities(name: ID): [ActivityType]
  customers(giaShortcut: ID): [CustomerType]
  groups(name: ID): [GroupType]
  roles(name: ID): [RoleType]
  userRoles: [UserRoleType]
  users(name: ID): [UserType]
}

type GroupType {
  customers: [String]
  description: String
  getRoles: [RoleType]
  id: String
  name: String
  roles: [Int]
  users: [String]
}

type RoleType {
  activities: [String]
  id: Int
  name: String
}

type UserRoleType {
  customer: String
  getRole: RoleType
  role: Int
  user: String
}

type ProcessType {
  businessModules: [BusinessModule]
  configManagement: ConfigManagementType
  customers: [Customer]
  servers(where: UidFilterType): [CustomServerType]
  services: [Service]
  users: [User]
  vms(where: UidFilterType): [Vm]
}

type ConfigManagementType {
  clients(where: UidFilterType): ConfigMgntClients
  history: HistoryType
  networkSystems(where: UidFilterType): ConfigMgntNetworkSystems
  servers(where: UidFilterType): ConfigMgntServers
}

type ConfigMgntServers {
  byOriginCount: [KeyValueStringDouble]
  byStateCount: [KeyValueStringDouble]
  count: Float
  items: [ConfigMgntServer]
}

type KeyValueStringDouble {
  key: String
  value: Float
}

type ConfigMgntServer {
  customer: String
  id: ID
  results: [ConfigMgntCompareResult]
  sources: [String]
  state: ConfigMgntState
  uid: ID
}

type ConfigMgntCompareResult {
  name: String
  precondition: String
  rule: String
  state: ConfigMgntState
  value: String
}

enum ConfigMgntState {
  HEALTHY
  WARNING
  UNHEALTHY
  NONE
}

type ConfigMgntClients {
  byOriginCount: [KeyValueStringDouble]
  byStateCount: [KeyValueStringDouble]
  count: Float
  items: [ConfigMgntClient]
}

type ConfigMgntClient {
  customer: String
  id: ID
  results: [ConfigMgntCompareResult]
  sources: [String]
  state: ConfigMgntState
  uid: ID
}

type ConfigMgntNetworkSystems {
  byOriginCount: [KeyValueStringDouble]
  byStateCount: [KeyValueStringDouble]
  count: Float
  items: [ConfigMgntNetworkSystem]
}

type ConfigMgntNetworkSystem {
  customer: String
  id: ID
  results: [ConfigMgntCompareResult]
  sources: [String]
  state: ConfigMgntState
  uid: ID
}

type HistoryType {
  clients: ConfigMgntHistoryClient
  networkSystems: ConfigMgntHistoryNetworkSystem
  servers: ConfigMgntHistoryServer
}

type ConfigMgntHistoryServer {
  items: [ConfigMgntHistoryItemServer]
}

type ConfigMgntHistoryItemServer {
  byOriginCount: [KeyValueStringDouble]
  byStateCount: [KeyValueStringDouble]
  captureDate: Date
  count: Float
  id: ID
  items: [ConfigMgntServer]
}

type ConfigMgntHistoryClient {
  items: [ConfigMgntHistoryItemClient]
}

type ConfigMgntHistoryItemClient {
  byOriginCount: [KeyValueStringDouble]
  byStateCount: [KeyValueStringDouble]
  captureDate: Date
  count: Float
  id: ID
  items: [ConfigMgntClient]
}

type ConfigMgntHistoryNetworkSystem {
  items: [ConfigMgntHistoryItemNetworkSystem]
}

type ConfigMgntHistoryItemNetworkSystem {
  byOriginCount: [KeyValueStringDouble]
  byStateCount: [KeyValueStringDouble]
  captureDate: Date
  count: Float
  id: ID
  items: [ConfigMgntNetworkSystem]
}

type GiaGraphMutation {
  administration: AdministrationMutationType
  customer(shortcut: ID!): [CustomerMutationType]
  process: ProcessMutationType
}

type CustomerMutationType {
  service: ServiceMutationType
  serviceManagement: ServiceManagementMutationType
}

type ServiceMutationType {
  citrix: CitrixMutationType
  client: ClientMutation
  messaging: MessagingMutationType
  network: NetworkMutationType
  vasco: VascoMutationType
}

type CitrixMutationType {
  licencing: CitrixLicencingMutationType
  store(storeName: String): StoreMutationType
}

type StoreMutationType {
  newVdisk: String
  publishToProd(comment: String): String
  publishToTest: String
  removeVdisk: String
  revertToMaintenance: String
}

type CitrixLicencingMutationType {
  usage: CitrixLicencingUsageMutationType
}

type CitrixLicencingUsageMutationType {
  users: CitrixLicencingUsageUserMutationType
}

type CitrixLicencingUsageUserMutationType {
  setUserFree(userName: String! domain: String! free: Boolean!): CitrixLicencingUserType
}

type ClientMutation {
  assignments: AssignmentMutationType
  resource: ResourceMutationType
}

type ResourceMutationType {
  client(where: UidFilterType): ClientMutationType
  dockingstation(where: UidFilterType): DockingstationMutationType
  monitor(where: UidFilterType): MonitorMutationType
  printer(where: UidFilterType): PrinterMutationType
  user(where: UidFilterType): UserMutationType
}

type ClientMutationType {
  change: ClientChangeImacMutation
  decom: ClientDecomImacMutation
  setup: ClientSetupImacMutation
}

type ClientSetupImacMutation {
  add(imac: ClientSetupImacInputType): ClientType
}

input ClientSetupImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  currentState: String!
  customer: String!
  model: String!
  location: String!
  assignTo: String!
  serialNumber: String!
  hostname: String!
  clientType: ClientClass
  businessModules: [String]
}

type ClientDecomImacMutation {
  add(imac: ClientDecomImacInputType): ClientType
}

input ClientDecomImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
}

type ClientChangeImacMutation {
  add(imac: ClientChangeImacInputType): ClientType
}

input ClientChangeImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  customer: String
  model: String
  location: String
  assignTo: String
  businessModules: [String]
}

type UserMutationType {
  change: UserChangeImacMutation
}

type UserChangeImacMutation {
  add(imac: UserChangeImacInputType): User
}

input UserChangeImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  firstName: String
  lastName: String
  location: String
}

type PrinterMutationType {
  change: PrinterChangeImacMutation
  decom: PrinterDecomImacMutation
  setup: PrinterSetupImacMutation
}

type PrinterSetupImacMutation {
  add(imac: PrinterSetupImacInputType): Printer
}

input PrinterSetupImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  currentState: String!
  customer: String!
  comment: String!
  location: String!
  assignTo: String!
  description: String!
  model: String!
  serialNumber: String!
  hostname: String!
  businessModules: [String]
}

type PrinterDecomImacMutation {
  add(imac: PrinterDecomImacInputType): Printer
}

input PrinterDecomImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
}

type PrinterChangeImacMutation {
  add(imac: PrinterChangeImacInputType): Printer
}

input PrinterChangeImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  customer: String
  comment: String
  location: String
  assignTo: String
  description: String
  model: String
  businessModules: [String]
}

type MonitorMutationType {
  change: MonitorChangeImacMutation
  decom: MonitorDecomImacMutation
  setup: MonitorSetupImacMutation
}

type MonitorSetupImacMutation {
  add(imac: MonitorSetupImacInputType): Monitor
}

input MonitorSetupImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  currentState: String!
  customer: String!
  comment: String!
  location: String!
  assignTo: String!
  description: String!
  model: String!
  serialNumber: String!
  businessModules: [String]
}

type MonitorDecomImacMutation {
  add(imac: MonitorDecomImacInputType): Monitor
}

input MonitorDecomImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
}

type MonitorChangeImacMutation {
  add(imac: MonitorChangeImacInputType): Monitor
}

input MonitorChangeImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  customer: String
  comment: String
  location: String
  assignTo: String
  description: String
  model: String
  businessModules: [String]
}

type DockingstationMutationType {
  change: DockingstationChangeImacMutation
  decom: DockingstationDecomImacMutation
  setup: DockingstationSetupImacMutation
}

type DockingstationSetupImacMutation {
  add(imac: DockingstationSetupImacInputType): Dockingstation
}

input DockingstationSetupImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  currentState: String!
  customer: String!
  comment: String!
  location: String!
  assignTo: String!
  description: String!
  model: String!
  serialNumber: String!
  businessModules: [String]
}

type DockingstationDecomImacMutation {
  add(imac: DockingstationDecomImacInputType): Dockingstation
}

input DockingstationDecomImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
}

type DockingstationChangeImacMutation {
  add(imac: DockingstationChangeImacInputType): Dockingstation
}

input DockingstationChangeImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  customer: String
  comment: String
  location: String
  assignTo: String
  description: String
  model: String
  businessModules: [String]
}

type AssignmentMutationType {
  addDeviceAssignment(assignments: DeviceAssignmentInputType): [DeviceAssignmentResultType]
  removeDeviceAssignment(assignments: DeviceAssignmentInputType): [DeviceAssignmentResultType]
}

type DeviceAssignmentResultType {
  collectionID: String!
  resultState: [AssignmentResultType]
}

type AssignmentResultType {
  name: String!
  result: String!
}

input DeviceAssignmentInputType {
  collectionIDs: [String!]!
  deviceNames: [String!]!
}

type NetworkMutationType {
  saveConfig(config: [NetworkServiceInputType]): [NetworkServicesType]
}

type MessagingMutationType {
  saveConfig(config: MessagingConfigurationInputType): MessagingConfigurationType
}

type VascoMutationType {
  assignNewToken: VascoTokenType
  sendVascoDownloadLink(phoneNumber: String): Boolean
  unassignToken(serialNumber: String): Boolean
  verifyCredentials(password: String oneTimePassword: String): Boolean
}

type ServiceManagementMutationType {
  server(where: UidFilterType): ServerMutationType
}

type ServerMutationType {
  change: ServerChangeImacMutation
  decom: ServerDecomImacMutation
  setup: ServerSetupImacMutation
}

type ServerSetupImacMutation {
  add(imac: ServerSetupImacInputType): ServerType
}

type ServerType {
  active: ActiveState
  alive: Boolean
  antimalware: Antimalware
  assetNumbers: [String]
  assignedServices: [String]
  backupPolicy: String
  businessModules: [String]
  comment: String
  consoleUsages: [ConsoleUsageType]
  contact: String
  contractNumbers: [String]
  cpus: [CPU]
  createdAt: DateTime
  customer: String
  description: String
  disks: [Disk]
  distinguishedName: String
  domain: String
  getAssignedIpAddresses: [IpAddress]
  getAssignedServices: [Service]
  getBusinessModules: [BusinessModule]
  getContact: User
  getCustomer: Customer
  getHostVirtualMachines: [Vm]
  getSecondaryContact: User
  history: [HistoryItem]
  hostDetails: HostDetails
  id: ID
  imacs: [ServerImacsType]
  infrastructure: String
  investmentNumbers: [String]
  ipAddresses: [String]
  isHost: Boolean
  isManagedByGIA: Boolean
  isNotBillable: Boolean
  isServer: Boolean
  isVirtualMachine: Boolean
  isVisibleToCustomer: Boolean
  lastLogon: DateTime
  lastOfflineTime: DateTime
  lastOnlineTime: DateTime
  manufacturer: String
  model: String
  netbiosName: String
  numberOfCores: Float
  numberOfLogicalProcessors: Float
  numberOfPhysicalProcessors: Float
  onlineStatus: Boolean
  operatingSystem: Os
  patchWindow: String
  principalName: String
  rebootState: Int
  region: String
  roles: [String]
  sccmAgent: Int
  sccmResourceId: String
  scomAgent: Int
  secondaryContact: String
  serialNumber: String
  serviceWindowApp: String
  serviceWindowPft: String
  sources: [String!]!
  systemClass: SystemClass
  systemClassTarget: SystemClass
  systemType: String
  totalDiskGB: Float
  totalMemoryMB: Float
  uid: String!
  updatedAt: DateTime
  version: ServerVersion
  volumes: [Volume]
}

input ServerSetupImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  imacId: String!
  archId: String!
  currentState: String!
  backupPolicy: String!
  explanation: String!
  region: String!
  description: String!
  satComment: String!
  networkComment: String!
  platformInstallComment: String!
  platformDistributionComment: String!
  platformConfigComment: String!
  serverType: String!
  networkVlan: String!
  hostname: String!
  ip: String!
  subnetMask: String!
  defaultGateway: String!
  vlan: String!
  vlanId: String!
  domain: String!
  primaryDns: String!
  secondaryDns: String!
  computeCluster: String!
  storageSystem: String!
  passwordSaved: Boolean
  customer: String!
  patchWindow: String!
  businessModules: [String]
  primaryOwner: String!
  secondaryOwner: String!
  requestedBy: String!
  scomUser: String!
  sccmUser: String!
  scepUser: String!
  scsmUser: String!
  visionAppUser: String!
  backupUser: String!
  serverSize: ServerSizeInputType
  sla: ServerSLAInputType
  systemClass: SystemClass
}

input ServerSizeInputType {
  name: String
  cpu: Int
  memory: Int
  disk: Int
}

input ServerSLAInputType {
  application: String
  platform: String
}

type ServerChangeImacMutation {
  add(imac: ServerChangeImacInputType): ServerType
}

input ServerChangeImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
  active: ActiveState
  cIState: CIState
  customer: String
  patchWindow: String
  primaryOwner: String
  region: String
  systemClass: SystemClass
  isVisibleToCustomer: Boolean
  isNotBillable: Boolean
  isManagedByGIA: Boolean
  infrastructure: String
  serviceWindowPft: String
  serviceWindowApp: String
  secondaryOwner: String
  backupPolicy: String
  comment: String
  investmentNumbers: [String]
  contractNumbers: [String]
  assetNumbers: [String]
  assignedServices: [String]
  businessModules: [String]
  description: String
}

type ServerDecomImacMutation {
  add(imac: ServerDecomImacInputType): ServerType
}

input ServerDecomImacInputType {
  ticketNumber: String
  note: String
  imacGuid: GuidGraphType
}

type AdministrationMutationType {
  security: SecurityMutationType
}

type SecurityMutationType {
  activities: ActivityMutationType
  customers: AdministrationCustomerMutationType
  groups: GroupMutationType
  roles: RoleMutationType
  userRoles: UserRoleMutationType
}

type GroupMutationType {
  editGroup(editGroup: GroupInputType): String
  newGroup(newGroup: GroupInputType): String
  removeGroup(id: ID): String
}

input GroupInputType {
  id: ID
  name: String
  description: String
  customers: [String]
  roles: [Int]
  users: [String]
}

type RoleMutationType {
  editRole(editRole: RoleInputType): String
  newRole(newRole: RoleInputType): String
  removeRole(id: ID): String
}

input RoleInputType {
  id: ID
  name: String
  activities: [String]
}

type ActivityMutationType {
  editActivity(editActivity: ActivityInputType): String
  newActivity(newActivity: ActivityInputType): String
  removeActivity(name: ID): String
}

input ActivityInputType {
  name: ID
  description: String
}

type AdministrationCustomerMutationType {
  editCustomer(editCustomer: CustomerInputType): String
  newCustomer(newCustomer: CustomerInputType): String
  removeCustomer(shortcut: ID): String
  setProperties(setProperties: CustomerSetPropertyInputType): String
}

input CustomerInputType {
  giaShortcut: String
  name: String
  domainSuffixes: [String]
  defaultRoles: [Int]
}

input CustomerSetPropertyInputType {
  giaShortcut: String
  properties: [CustomerPropertyInputType]
}

input CustomerPropertyInputType {
  name: String
  value: String
}

type UserRoleMutationType {
  newUserRoles(newUserRoles: UserRolesInputType): String
  removeUserRole(removeUserRole: UserRoleInputType): String
}

input UserRolesInputType {
  user: String
  customers: [String]
  roles: [Int]
}

input UserRoleInputType {
  user: String
  customer: String
  role: Int
}

type ProcessMutationType {
  configManagement: ConfigManagementMutation
}

type ConfigManagementMutation {
  server(where: UidFilterType): ServerMutationType
}

"Directs the executor to include this field or fragment only when the 'if' argument is true."
directive @include("Included when true." if: Boolean!) on FIELD | FIELD_DEFINITION | INLINE_FRAGMENT | FRAGMENT_SPREAD

"Directs the executor to skip this field or fragment when the 'if' argument is true."
directive @skip("Skipped when true." if: Boolean!) on FIELD | FIELD_DEFINITION | INLINE_FRAGMENT | FRAGMENT_SPREAD
